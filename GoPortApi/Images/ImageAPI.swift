//
// ImageAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct ImageAPI {
    
    internal enum ImageAPIPath: APIPathProtocol {
        case buildPrune
        case imageBuild
        case imageCommit
        case imageCreate
        case imageDelete(name: String)
        case imageHistory(name: String)
        case imageInspect(name: String)
        case imageList
        case imageLoad
        case imagePrune
        case imagePush(name: String)
        case imageSearch
        case imageTag(name: String)
        
        var path: String {
            switch self {
            case .buildPrune: return "/build/prune"
            case .imageBuild: return "/build"
            case .imageCommit: return "/commit"
            case .imageCreate: return "/images/create"
            case .imageDelete(let name):
                var localPath = "/images/{name}"
                localPath = localPath.replacingOccurrences(of: "{name}", with: mapToPathItem(name), options: .literal, range: nil)
                return localPath
            case .imageHistory(let name):
                var localPath = "/images/{name}/history"
                localPath = localPath.replacingOccurrences(of: "{name}", with: mapToPathItem(name), options: .literal, range: nil)
                return localPath
            case .imageInspect(let name):
                var localPath = "/images/{name}/json"
                localPath = localPath.replacingOccurrences(of: "{name}", with: mapToPathItem(name), options: .literal, range: nil)
                return localPath
            case .imageList: return "/images/json"
            case .imageLoad: return "/images/load"
            case .imagePrune: return "/images/prune"
            case .imagePush(let name):
                var localPath = "/images/{name}/push"
                localPath = localPath.replacingOccurrences(of: "{name}", with: mapToPathItem(name), options: .literal, range: nil)
                return localPath
            case .imageSearch: return "/images/search"
            case .imageTag(let name):
                var localPath = "/images/{name}/tag"
                localPath = localPath.replacingOccurrences(of: "{name}", with: mapToPathItem(name), options: .literal, range: nil)
                return localPath
            }
        }
    }
    
    /**
     Create a new image from a container
     - POST /commit
     - parameter context: (query) The context to connect to. (optional)
     - parameter container: (query) The ID or name of the container to commit (optional)
     - parameter repo: (query) Repository name for the created image (optional)
     - parameter tag: (query) Tag name for the create image (optional)
     - parameter comment: (query) Commit message (optional)
     - parameter author: (query) Author of the image (e.g., &#x60;John Hannibal Smith &lt;hannibal@a-team.com&gt;&#x60;) (optional)
     - parameter pause: (query) Whether to pause the container before committing (optional, default to true)
     - parameter changes: (query) &#x60;Dockerfile&#x60; instructions to apply while committing (optional)
     - parameter containerConfig: (body) The container configuration (optional)
     - returns: IdResponse
     */
    public static func imageCommit(host: URL, context: String? = nil, container: String? = nil, repo: String? = nil, tag: String? = nil, comment: String? = nil, author: String? = nil, pause: Bool? = nil, changes: [String]? = nil, containerConfig: ContainerConfig? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> IdResponse {
        try await session.load(APIRequest(method: .POST, host: host, path: ImageAPIPath.imageCommit, query: [
            "context": context,
            "container": container,
            "repo": repo,
            "tag": tag,
            "comment": comment,
            "author": author,
            "pause": pause,
            "changes": changes,
        ], body: containerConfig))
    }
    
    /**
     Create an image
     - POST /images/create
     - Create an image by either pulling it from a registry or importing it.
     - parameter context: (query) The context to connect to. (optional)
     - parameter fromImage: (query) Name of the image to pull. The name may include a tag or digest. This parameter may only be used when pulling an image. The pull is cancelled if the HTTP connection is closed. (optional)
     - parameter fromSrc: (query) Source to import. The value may be a URL from which the image can be retrieved or &#x60;-&#x60; to read the image from the request body. This parameter may only be used when importing an image. (optional)
     - parameter repo: (query) Repository name given to an image when it is imported. The repo may include a tag. This parameter may only be used when importing an image. (optional)
     - parameter tag: (query) Tag or digest. If empty when pulling an image, this causes all tags for the given image to be pulled. (optional)
     - parameter message: (query) Set commit message for imported image. (optional)
     - parameter xRegistryAuth: (header) A base64url-encoded auth configuration.  Refer to the [authentication section](#section/Authentication) for details.  (optional)
     - parameter platform: (query) Platform in the format os[/arch[/variant]] (optional)
     - parameter quiet: (query) Show logs when pulling. (optional, default to true)
     - parameter inputImage: (body) Image content if the value &#x60;-&#x60; has been specified in fromSrc query parameter (optional)
     
     */
    public static func imageCreate(host: URL, context: String? = nil, fromImage: String? = nil, fromSrc: String? = nil, repo: String? = nil, tag: String? = nil, message: String? = nil, xRegistryAuth: String? = nil, platform: String? = nil, quiet: Bool? = nil, inputImage: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> APIStreamResponse<ProgressResponse> {
        var headers = [String:String]()
        if let xRegistryAuth = xRegistryAuth {
            headers["X-Registry-Auth"] = xRegistryAuth
        }
        return try await session.stream(APIRequest(method: .POST, host: host, path: ImageAPIPath.imageCreate, query: [
            "context": context,
            "fromImage": fromImage,
            "fromSrc": fromSrc,
            "repo": repo,
            "tag": tag,
            "message": message,
            "platform": platform,
            "quiet": quiet,
        ], header: headers, body: inputImage))
    }
    
    /**
     Remove an image
     - DELETE /images/{name}
     - Remove an image, along with any untagged parent images that were referenced by that image.  Images can't be removed if they have descendant images, are being used by a running container or are being used by a build.
     - parameter name: (path) Image name or ID
     - parameter context: (query) The context to connect to. (optional)
     - parameter force: (query) Remove the image even if it is being used by stopped containers or has other tags (optional, default to false)
     - parameter noprune: (query) Do not delete untagged parent images (optional, default to false)
     - returns: [ImageDeleteResponseItem]
     */
    public static func imageDelete(host: URL, name: String, context: String? = nil, force: Bool? = nil, noprune: Bool? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> ImageDeleteResponse {
        try await session.load(APIRequest(method: .DELETE, host: host, path: ImageAPIPath.imageDelete(name: name), query: [
            "context": context,
            "force": force,
            "noprune": noprune,
        ]))
    }
    
    /**
     Get the history of an image
     - GET /images/{name}/history
     - Return parent layers of an image.
     - parameter name: (path) Image name or ID
     - parameter context: (query) The context to connect to. (optional)
     - returns: [HistoryResponseItem]
     */
    public static func imageHistory(host: URL, name: String, context: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> HistoryResponse {
        try await session.load(APIRequest(method: .GET, host: host, path: ImageAPIPath.imageHistory(name: name), query: [
            "context": context,
        ]))
    }
    
    /**
     Inspect an image
     - GET /images/{name}/json
     - Return low-level information about an image.
     - parameter name: (path) Image name or id
     - parameter context: (query) The context to connect to. (optional)
     - returns: Image
     */
    public static func imageInspect(host: URL, name: String, context: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> ImageResponse {
        try await session.load(APIRequest(method: .GET, host: host, path: ImageAPIPath.imageInspect(name: name), query: [
            "context": context,
        ]))
    }
    
    /**
     List Images
     - GET /images/json
     - Returns a list of images on the server. Note that it uses a different, smaller representation of an image than inspecting a single image.
     - parameter context: (query) The contexts to connect to. (optional)
     - parameter all: (query) Show all images. Only images from a final layer (no children) are shown by default. (optional, default to false)
     - parameter filters: (query) A JSON encoded value of the filters (a &#x60;map[string][]string&#x60;) to process on the images list.  Available filters:  - &#x60;before&#x60;&#x3D;(&#x60;&lt;image-name&gt;[:&lt;tag&gt;]&#x60;,  &#x60;&lt;image id&gt;&#x60; or &#x60;&lt;image@digest&gt;&#x60;) - &#x60;dangling&#x3D;true&#x60; - &#x60;label&#x3D;key&#x60; or &#x60;label&#x3D;\&quot;key&#x3D;value\&quot;&#x60; of an image label - &#x60;reference&#x60;&#x3D;(&#x60;&lt;image-name&gt;[:&lt;tag&gt;]&#x60;) - &#x60;since&#x60;&#x3D;(&#x60;&lt;image-name&gt;[:&lt;tag&gt;]&#x60;,  &#x60;&lt;image id&gt;&#x60; or &#x60;&lt;image@digest&gt;&#x60;)  (optional)
     - parameter digests: (query) Show digest information as a &#x60;RepoDigests&#x60; field on each image. (optional, default to false)
     - returns: [String: [ImageSummary]]
     */
    public static func imageList(host: URL, context: [String]? = nil, all: Bool? = nil, filters: String? = nil, digests: Bool? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> ImageListResponse {
        try await session.load(APIRequest(method: .GET, host: host, path: ImageAPIPath.imageList, query: [
            "context": context,
            "all": all,
            "filters": filters,
            "digests": digests,
        ]))
    }
    
    /**
     Import images
     - POST /images/load
     - Load a set of images and tags into a repository.  For details on the format, see the [export image endpoint](#operation/ImageGet).
     - parameter context: (query) The context to connect to. (optional)
     - parameter quiet: (query) Suppress progress details during load. (optional, default to false)
     - parameter imagesTarball: (body) Tar archive containing images (optional)
     
     */
    public static func imageLoad(host: URL, context: String? = nil, quiet: Bool? = nil, imagesTarball: URL? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> APIStreamResponse<ProgressResponse> {
        try await session.stream(APIRequest(method: .POST, host: host, path: ImageAPIPath.imageLoad, query: [
            "context": context,
            "quiet": quiet,
        ], body: imagesTarball))
    }
    
    /**
     Delete unused images
     - POST /images/prune
     - parameter context: (query) The contexts to connect to. (optional)
     - parameter filters: (query) Filters to process on the prune list, encoded as JSON (a &#x60;map[string][]string&#x60;). Available filters:  - &#x60;dangling&#x3D;&lt;boolean&gt;&#x60; When set to &#x60;true&#x60; (or &#x60;1&#x60;), prune only    unused *and* untagged images. When set to &#x60;false&#x60;    (or &#x60;0&#x60;), all unused images are pruned. - &#x60;until&#x3D;&lt;string&gt;&#x60; Prune images created before this timestamp. The &#x60;&lt;timestamp&gt;&#x60; can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. &#x60;10m&#x60;, &#x60;1h30m&#x60;) computed relative to the daemon machine’s time. - &#x60;label&#x60; (&#x60;label&#x3D;&lt;key&gt;&#x60;, &#x60;label&#x3D;&lt;key&gt;&#x3D;&lt;value&gt;&#x60;, &#x60;label!&#x3D;&lt;key&gt;&#x60;, or &#x60;label!&#x3D;&lt;key&gt;&#x3D;&lt;value&gt;&#x60;) Prune images with (or without, in case &#x60;label!&#x3D;...&#x60; is used) the specified labels.  (optional)
     - returns: ImagePruneResponse
     */
    public static func imagePrune(host: URL, context: [String]? = nil, filters: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> ImagePruneResponse {
        try await session.load(APIRequest(method: .POST, host: host, path: ImageAPIPath.imagePrune, query: [
            "context": context,
            "filters": filters,
        ]))
    }
    
    /**
     Push an image
     - POST /images/{name}/push
     - Push an image to a registry.  If you wish to push an image on to a private registry, that image must already have a tag which references the registry. For example, `registry.example.com/myimage:latest`.  The push is cancelled if the HTTP connection is closed.
     - parameter name: (path) Image name or ID.
     - parameter xRegistryAuth: (header) A base64url-encoded auth configuration.  Refer to the [authentication section](#section/Authentication) for details.
     - parameter context: (query) The context to connect to. (optional)
     - parameter tag: (query) The tag to associate with the image on the registry. (optional)
     
     */
    public static func imagePush(host: URL, name: String, xRegistryAuth: String, context: String? = nil, tag: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> APIStreamResponse<ProgressResponse> {
        let headers = ["X-Registry-Auth": xRegistryAuth]
        return try await session.stream(APIRequest(method: .POST, host: host, path: ImageAPIPath.imagePush(name: name), query: [
            "context": context,
            "tag": tag,
        ], header: headers))
    }
    
    /**
     Search images
     - GET /images/search
     - Search for an image on Docker Hub.
     - parameter term: (query) Term to search
     - parameter context: (query) The context to connect to. (optional)
     - parameter limit: (query) Maximum number of results to return (optional)
     - parameter filters: (query) A JSON encoded value of the filters (a &#x60;map[string][]string&#x60;) to process on the images list. Available filters:  - &#x60;is-automated&#x3D;(true|false)&#x60; - &#x60;is-official&#x3D;(true|false)&#x60; - &#x60;stars&#x3D;&lt;number&gt;&#x60; Matches images that has at least &#39;number&#39; stars.  (optional)
     - returns: [ImageSearchResponseItem]
     */
    public static func imageSearch(host: URL, term: String, context: String? = nil, limit: Int? = nil, filters: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> ImageSearchResponse {
        try await session.load(APIRequest(method: .GET, host: host, path: ImageAPIPath.imageSearch, query: [
            "context": context,
            "term": term,
            "limit": limit,
            "filters": filters,
        ]))
    }
    
    /**
     Tag an image
     - POST /images/{name}/tag
     - Tag an image so that it becomes part of a repository.
     - parameter name: (path) Image name or ID to tag.
     - parameter context: (query) The context to connect to. (optional)
     - parameter repo: (query) The repository to tag in. For example, &#x60;someuser/someimage&#x60;. (optional)
     - parameter tag: (query) The name of the new tag. (optional)
     
     */
    public static func imageTag(host: URL, name: String, context: String? = nil, repo: String? = nil, tag: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws {
        try await session.load(APIRequest(method: .POST, host: host, path: ImageAPIPath.imageTag(name: name), query: [
            "context": context,
            "repo": repo,
            "tag": tag,
        ]))
    }
}
