//
// NetworkAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct NetworkAPI {
    
    internal enum NetworkAPIPath: APIPathProtocol {
        case networkConnect(id: String)
        case networkCreate
        case networkDelete(id: String)
        case networkDisconnect(id: String)
        case networkInspect(id: String)
        case networkList
        case networkPrune
        
        var path: String {
            switch self {
            case .networkConnect(let id):
                var localPath = "/networks/{id}/connect"
                localPath = localPath.replacingOccurrences(of: "{id}", with: mapToPathItem(id), options: .literal, range: nil)
                return localPath
            case .networkCreate: return "/networks/create"
            case .networkDelete(let id):
                var localPath = "/networks/{id}"
                localPath = localPath.replacingOccurrences(of: "{id}", with: mapToPathItem(id), options: .literal, range: nil)
                return localPath
            case .networkDisconnect(let id):
                var localPath = "/networks/{id}/disconnect"
                localPath = localPath.replacingOccurrences(of: "{id}", with: mapToPathItem(id), options: .literal, range: nil)
                return localPath
            case .networkInspect(let id):
                var localPath = "/networks/{id}"
                localPath = localPath.replacingOccurrences(of: "{id}", with: mapToPathItem(id), options: .literal, range: nil)
                return localPath
            case .networkList: return "/networks"
            case .networkPrune: return "/networks/prune"
            }
        }
    }
    
    /**
     Connect a container to a network
     - POST /networks/{id}/connect
     - parameter id: (path) Network ID or name
     - parameter container: (body)
     - parameter context: (query) The context to connect to. (optional)
     
     */
    public static func networkConnect(host: URL, id: String, container: NetworkContainerConnectConfig, context: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws {
        try await session.load(APIRequest(method: .POST, host: host, path: NetworkAPIPath.networkConnect(id: id), query: [
            "context": context,
        ], body: container))
    }
    
    /**
     Create a network
     - POST /networks/create
     - parameter networkConfig: (body)
     - parameter context: (query) The context to connect to. (optional)
     - returns: NetworkCreateResponse
     */
    public static func networkCreate(host: URL, networkConfig: NetworkConfig, context: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> NetworkCreateResponse {
        try await session.load(APIRequest(method: .POST, host: host, path: NetworkAPIPath.networkCreate, query: [
            "context": context,
        ], body: networkConfig))
    }
    
    /**
     Remove a network
     - DELETE /networks/{id}
     - parameter id: (path) Network ID or name
     - parameter context: (query) The context to connect to. (optional)
     
     */
    public static func networkDelete(host: URL, id: String, context: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws {
        try await session.load(APIRequest(method: .DELETE, host: host, path: NetworkAPIPath.networkDelete(id: id), query: [
            "context": context,
        ]))
    }
    
    /**
     Disconnect a container from a network
     - POST /networks/{id}/disconnect
     - parameter id: (path) Network ID or name
     - parameter container: (body)
     - parameter context: (query) The context to connect to. (optional)
     
     */
    public static func networkDisconnect(host: URL, id: String, container: NetworkDisconnectConfig, context: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws {
        try await session.load(APIRequest(method: .POST, host: host, path: NetworkAPIPath.networkDisconnect(id: id), query: [
            "context": context,
        ], body: container))
    }
    
    /**
     Inspect a network
     - GET /networks/{id}
     - parameter id: (path) Network ID or name
     - parameter context: (query) The context to connect to. (optional)
     - parameter verbose: (query) Detailed inspect output for troubleshooting (optional, default to false)
     - parameter scope: (query) Filter the network by scope (swarm, global, or local) (optional)
     - returns: Network
     */
    public static func networkInspect(host: URL, id: String, context: String? = nil, verbose: Bool? = nil, scope: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> NetworkResponse {
        try await session.load(APIRequest(method: .GET, host: host, path: NetworkAPIPath.networkInspect(id: id), query: [
            "context": context,
            "verbose": verbose,
            "scope": scope,
        ]))
    }
    
    /**
     List networks
     - GET /networks
     - Returns a list of networks. For details on the format, see the [network inspect endpoint](#operation/NetworkInspect).  Note that it uses a different, smaller representation of a network than inspecting a single network. For example, the list of containers attached to the network is not propagated in API versions 1.28 and up.
     - parameter context: (query) The contexts to connect to. (optional)
     - parameter filters: (query) JSON encoded value of the filters (a &#x60;map[string][]string&#x60;) to process on the networks list.  Available filters:  - &#x60;dangling&#x3D;&lt;boolean&gt;&#x60; When set to &#x60;true&#x60; (or &#x60;1&#x60;), returns all    networks that are not in use by a container. When set to &#x60;false&#x60;    (or &#x60;0&#x60;), only networks that are in use by one or more    containers are returned. - &#x60;driver&#x3D;&lt;driver-name&gt;&#x60; Matches a network&#39;s driver. - &#x60;id&#x3D;&lt;network-id&gt;&#x60; Matches all or part of a network ID. - &#x60;label&#x3D;&lt;key&gt;&#x60; or &#x60;label&#x3D;&lt;key&gt;&#x3D;&lt;value&gt;&#x60; of a network label. - &#x60;name&#x3D;&lt;network-name&gt;&#x60; Matches all or part of a network name. - &#x60;scope&#x3D;[\&quot;swarm\&quot;|\&quot;global\&quot;|\&quot;local\&quot;]&#x60; Filters networks by scope (&#x60;swarm&#x60;, &#x60;global&#x60;, or &#x60;local&#x60;). - &#x60;type&#x3D;[\&quot;custom\&quot;|\&quot;builtin\&quot;]&#x60; Filters networks by type. The &#x60;custom&#x60; keyword returns all user-defined networks.  (optional)
     - returns: [String: [Network]]
     */
    public static func networkList(host: URL, context: [String]? = nil, filters: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> NetworkListResponse {
        try await session.load(APIRequest(method: .GET, host: host, path: NetworkAPIPath.networkList, query: [
            "context": context,
            "filters": filters,
        ]))
    }
    
    /**
     Delete unused networks
     - POST /networks/prune
     - parameter context: (query) The contexts to connect to. (optional)
     - parameter filters: (query) Filters to process on the prune list, encoded as JSON (a &#x60;map[string][]string&#x60;).  Available filters: - &#x60;until&#x3D;&lt;timestamp&gt;&#x60; Prune networks created before this timestamp. The &#x60;&lt;timestamp&gt;&#x60; can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. &#x60;10m&#x60;, &#x60;1h30m&#x60;) computed relative to the daemon machineâ€™s time. - &#x60;label&#x60; (&#x60;label&#x3D;&lt;key&gt;&#x60;, &#x60;label&#x3D;&lt;key&gt;&#x3D;&lt;value&gt;&#x60;, &#x60;label!&#x3D;&lt;key&gt;&#x60;, or &#x60;label!&#x3D;&lt;key&gt;&#x3D;&lt;value&gt;&#x60;) Prune networks with (or without, in case &#x60;label!&#x3D;...&#x60; is used) the specified labels.  (optional)
     - returns: NetworkPruneResponse
     */
    public static func networkPrune(host: URL, context: [String]? = nil, filters: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> NetworkPruneResponse {
        try await session.load(APIRequest(method: .POST, host: host, path: NetworkAPIPath.networkPrune, query: [
            "context": context,
            "filters": filters,
        ]))
    }
}
