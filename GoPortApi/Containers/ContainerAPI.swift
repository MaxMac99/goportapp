//
// ContainerAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct ContainerAPI {
    
    internal enum ContainerAPIPath: APIPathProtocol {
        case containerChanges(id: String)
        case containerCreate
        case containerDelete(id: String)
        case containerExport(id: String)
        case containerInspect(id: String)
        case containerKill(id: String)
        case containerList
        case containerLogs(id: String)
        case containerPause(id: String)
        case containerPrune
        case containerRename(id: String)
        case containerResize(id: String)
        case containerRestart(id: String)
        case containerStart(id: String)
        case containerStats(id: String)
        case containerStop(id: String)
        case containerTop(id: String)
        case containerUnpause(id: String)
        case containerUpdate(id: String)
        case containerWait(id: String)
        
        var path: String {
            switch self {
            case .containerChanges(let id):
                var localPath = "/containers/{id}/changes"
                localPath = localPath.replacingOccurrences(of: "{id}", with: mapToPathItem(id), options: .literal, range: nil)
                return localPath
            case .containerCreate: return "/containers/create"
            case .containerDelete(let id):
                var localPath = "/containers/{id}"
                localPath = localPath.replacingOccurrences(of: "{id}", with: mapToPathItem(id), options: .literal, range: nil)
                return localPath
            case .containerExport(let id):
                var localPath = "/containers/{id}/export"
                localPath = localPath.replacingOccurrences(of: "{id}", with: mapToPathItem(id), options: .literal, range: nil)
                return localPath
            case .containerInspect(let id):
                var localPath = "/containers/{id}/json"
                localPath = localPath.replacingOccurrences(of: "{id}", with: mapToPathItem(id), options: .literal, range: nil)
                return localPath
            case .containerKill(let id):
                var localPath = "/containers/{id}/kill"
                localPath = localPath.replacingOccurrences(of: "{id}", with: mapToPathItem(id), options: .literal, range: nil)
                return localPath
            case .containerList: return "/containers/json"
            case .containerLogs(let id):
                var localPath = "/containers/{id}/logs"
                localPath = localPath.replacingOccurrences(of: "{id}", with: mapToPathItem(id), options: .literal, range: nil)
                return localPath
            case .containerPause(let id):
                var localPath = "/containers/{id}/pause"
                localPath = localPath.replacingOccurrences(of: "{id}", with: mapToPathItem(id), options: .literal, range: nil)
                return localPath
            case .containerPrune: return "/containers/prune"
            case .containerRename(let id):
                var localPath = "/containers/{id}/rename"
                localPath = localPath.replacingOccurrences(of: "{id}", with: mapToPathItem(id), options: .literal, range: nil)
                return localPath
            case .containerResize(let id):
                var localPath = "/containers/{id}/resize"
                localPath = localPath.replacingOccurrences(of: "{id}", with: mapToPathItem(id), options: .literal, range: nil)
                return localPath
            case .containerRestart(let id):
                var localPath = "/containers/{id}/restart"
                localPath = localPath.replacingOccurrences(of: "{id}", with: mapToPathItem(id), options: .literal, range: nil)
                return localPath
            case .containerStart(let id):
                var localPath = "/containers/{id}/start"
                localPath = localPath.replacingOccurrences(of: "{id}", with: mapToPathItem(id), options: .literal, range: nil)
                return localPath
            case .containerStats(let id):
                var localPath = "/containers/{id}/stats"
                localPath = localPath.replacingOccurrences(of: "{id}", with: mapToPathItem(id), options: .literal, range: nil)
                return localPath
            case .containerStop(let id):
                var localPath = "/containers/{id}/stop"
                localPath = localPath.replacingOccurrences(of: "{id}", with: mapToPathItem(id), options: .literal, range: nil)
                return localPath
            case .containerTop(let id):
                var localPath = "/containers/{id}/top"
                localPath = localPath.replacingOccurrences(of: "{id}", with: mapToPathItem(id), options: .literal, range: nil)
                return localPath
            case .containerUnpause(let id):
                var localPath = "/containers/{id}/unpause"
                localPath = localPath.replacingOccurrences(of: "{id}", with: mapToPathItem(id), options: .literal, range: nil)
                return localPath
            case .containerUpdate(let id):
                var localPath = "/containers/{id}/update"
                localPath = localPath.replacingOccurrences(of: "{id}", with: mapToPathItem(id), options: .literal, range: nil)
                return localPath
            case .containerWait(let id):
                var localPath = "/containers/{id}/wait"
                localPath = localPath.replacingOccurrences(of: "{id}", with: mapToPathItem(id), options: .literal, range: nil)
                return localPath
            }
        }
    }
    
    /**
     Get changes on a container’s filesystem
     - GET /containers/{id}/changes
     - Returns which files in a container's filesystem have been added, deleted, or modified. The `Kind` of modification can be one of:  - `0`: Modified - `1`: Added - `2`: Deleted
     - parameter id: (path) ID or name of the container
     - parameter context: (query) The context to connect to. (optional)
     - returns: ContainerChangeResponse
     */
    public static func containerChanges(host: URL, id: String, context: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> ContainerChangeResponse {
        try await session.load(APIRequest(method: .GET, host: host, path: ContainerAPIPath.containerChanges(id: id), query: [
            "context": context,
        ]))
    }
    
    /**
     Create a container
     - POST /containers/create
     - parameter body: (body) Container to create
     - parameter context: (query) The context to connect to. (optional)
     - parameter name: (query) Assign the specified name to the container. Must match &#x60;/?[a-zA-Z0-9][a-zA-Z0-9_.-]+&#x60;.  (optional)
     - returns: ContainerCreateResponse
     */
    public static func containerCreate(host: URL, body: ContainerCreateConfig, context: String? = nil, name: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> ContainerCreateResponse {
        try await session.load(APIRequest(method: .POST, host: host, path: ContainerAPIPath.containerCreate, query: [
            "context": context,
            "name": name,
        ], body: body))
    }
    
    /**
     Remove a container
     - DELETE /containers/{id}
     - parameter id: (path) ID or name of the container
     - parameter context: (query) The context to connect to. (optional)
     - parameter v: (query) Remove anonymous volumes associated with the container. (optional, default to false)
     - parameter force: (query) If the container is running, kill it before removing it. (optional, default to false)
     - parameter link: (query) Remove the specified link associated with the container. (optional, default to false)
     
     */
    public static func containerDelete(host: URL, id: String, context: String? = nil, v: Bool? = nil, force: Bool? = nil, link: Bool? = nil, session: NetworkingSession = NetworkingSession.shared) async throws {
        try await session.load(APIRequest(method: .DELETE, host: host, path: ContainerAPIPath.containerDelete(id: id), query: [
            "context": context,
            "v": v,
            "force": force,
            "link": link,
        ]))
    }
    
    /**
     Export a container
     - GET /containers/{id}/export
     - Export the contents of a container as a tarball.
     - parameter id: (path) ID or name of the container
     - parameter context: (query) The context to connect to. (optional)
     - returns: Data
     */
    public static func containerExport(host: URL, id: String, context: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> Data {
        try await session.load(APIRequest(method: .GET, host: host, path: ContainerAPIPath.containerExport(id: id), query: [
            "context": context,
        ]))
    }
    
    /**
     Inspect a container
     - GET /containers/{id}/json
     - Return low-level information about a container.
     - parameter id: (path) ID or name of the container
     - parameter context: (query) The context to connect to. (optional)
     - parameter size: (query) Return the size of container as fields &#x60;SizeRw&#x60; and &#x60;SizeRootFs&#x60; (optional, default to false)
     - returns: ContainerInspectResponse
     */
    public static func containerInspect(host: URL, id: String, context: String? = nil, size: Bool? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> ContainerInspectResponse {
        try await session.load(APIRequest(method: .GET, host: host, path: ContainerAPIPath.containerInspect(id: id), query: [
            "context": context,
            "size": size,
        ]))
    }
    
    /**
     Kill a container
     - POST /containers/{id}/kill
     - Send a POSIX signal to a container, defaulting to killing to the container.
     - parameter id: (path) ID or name of the container
     - parameter context: (query) The context to connect to. (optional)
     - parameter signal: (query) Signal to send to the container as an integer or string (e.g. &#x60;SIGINT&#x60;) (optional, default to "SIGKILL")
     
     */
    public static func containerKill(host: URL, id: String, context: String? = nil, signal: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws {
        try await session.load(APIRequest(method: .POST, host: host, path: ContainerAPIPath.containerKill(id: id), query: [
            "context": context,
            "signal": signal,
        ]))
    }
    
    /**
     List containers
     - GET /containers/json
     - Returns a list of containers. For details on the format, see the [inspect endpoint](#operation/ContainerInspect).  Note that it uses a different, smaller representation of a container than inspecting a single container. For example, the list of linked containers is not propagated .
     - parameter context: (query) The contexts to connect to. (optional)
     - parameter all: (query) Return all containers. By default, only running containers are shown.  (optional, default to false)
     - parameter limit: (query) Return this number of most recently created containers, including non-running ones.  (optional)
     - parameter size: (query) Return the size of container as fields &#x60;SizeRw&#x60; and &#x60;SizeRootFs&#x60;.  (optional, default to false)
     - parameter filters: (query) Filters to process on the container list, encoded as JSON (a &#x60;map[string][]string&#x60;). For example, &#x60;{\&quot;status\&quot;: [\&quot;paused\&quot;]}&#x60; will only return paused containers.  Available filters:  - &#x60;ancestor&#x60;&#x3D;(&#x60;&lt;image-name&gt;[:&lt;tag&gt;]&#x60;, &#x60;&lt;image id&gt;&#x60;, or &#x60;&lt;image@digest&gt;&#x60;) - &#x60;before&#x60;&#x3D;(&#x60;&lt;container id&gt;&#x60; or &#x60;&lt;container name&gt;&#x60;) - &#x60;expose&#x60;&#x3D;(&#x60;&lt;port&gt;[/&lt;proto&gt;]&#x60;|&#x60;&lt;startport-endport&gt;/[&lt;proto&gt;]&#x60;) - &#x60;exited&#x3D;&lt;int&gt;&#x60; containers with exit code of &#x60;&lt;int&gt;&#x60; - &#x60;health&#x60;&#x3D;(&#x60;starting&#x60;|&#x60;healthy&#x60;|&#x60;unhealthy&#x60;|&#x60;none&#x60;) - &#x60;id&#x3D;&lt;ID&gt;&#x60; a container&#39;s ID - &#x60;isolation&#x3D;&#x60;(&#x60;default&#x60;|&#x60;process&#x60;|&#x60;hyperv&#x60;) (Windows daemon only) - &#x60;is-task&#x3D;&#x60;(&#x60;true&#x60;|&#x60;false&#x60;) - &#x60;label&#x3D;key&#x60; or &#x60;label&#x3D;\&quot;key&#x3D;value\&quot;&#x60; of a container label - &#x60;name&#x3D;&lt;name&gt;&#x60; a container&#39;s name - &#x60;network&#x60;&#x3D;(&#x60;&lt;network id&gt;&#x60; or &#x60;&lt;network name&gt;&#x60;) - &#x60;publish&#x60;&#x3D;(&#x60;&lt;port&gt;[/&lt;proto&gt;]&#x60;|&#x60;&lt;startport-endport&gt;/[&lt;proto&gt;]&#x60;) - &#x60;since&#x60;&#x3D;(&#x60;&lt;container id&gt;&#x60; or &#x60;&lt;container name&gt;&#x60;) - &#x60;status&#x3D;&#x60;(&#x60;created&#x60;|&#x60;restarting&#x60;|&#x60;running&#x60;|&#x60;removing&#x60;|&#x60;paused&#x60;|&#x60;exited&#x60;|&#x60;dead&#x60;) - &#x60;volume&#x60;&#x3D;(&#x60;&lt;volume name&gt;&#x60; or &#x60;&lt;mount point destination&gt;&#x60;)  (optional)
     - returns: [String: [ContainerSummary]]
     */
    public static func containerList(host: URL, context: [String]? = nil, all: Bool? = nil, limit: Int? = nil, size: Bool? = nil, filters: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> ContainerSummaryResponse {
        try await session.load(APIRequest(method: .GET, host: host, path: ContainerAPIPath.containerList, query: [
            "context": context,
            "all": all,
            "limit": limit,
            "size": size,
            "filters": filters,
        ]))
    }
    
    /**
     Get container logs
     - GET /containers/{id}/logs
     - Get `stdout` and `stderr` logs from a container.  Note: This endpoint works only for containers with the `json-file` or `journald` logging driver.
     - parameter id: (path) ID or name of the container
     - parameter context: (query) The context to connect to. (optional)
     - parameter follow: (query) Keep connection after returning logs. (optional, default to false)
     - parameter stdout: (query) Return logs from &#x60;stdout&#x60; (optional, default to false)
     - parameter stderr: (query) Return logs from &#x60;stderr&#x60; (optional, default to false)
     - parameter since: (query) Only return logs since this time, as a UNIX timestamp (optional, default to 0)
     - parameter until: (query) Only return logs before this time, as a UNIX timestamp (optional, default to 0)
     - parameter timestamps: (query) Add timestamps to every log line (optional, default to false)
     - parameter tail: (query) Only return this number of log lines from the end of the logs. Specify as an integer or &#x60;all&#x60; to output all log lines.  (optional, default to "all")
     - returns: URL
     */
    public static func containerLogs(host: URL, id: String, context: String? = nil, stdout: Bool? = nil, stderr: Bool? = nil, since: Int? = nil, until: Int? = nil, timestamps: Bool? = nil, tail: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> ContainerLogResponse {
        try await session.load(APIRequest(method: .GET, host: host, path: ContainerAPIPath.containerLogs(id: id), query: [
            "context": context,
            "follow": false,
            "stdout": stdout,
            "stderr": stderr,
            "since": since,
            "until": until,
            "timestamps": timestamps,
            "tail": tail,
        ]))
    }
    
    /**
     Get container logs
     - GET /containers/{id}/logs
     - Get `stdout` and `stderr` logs from a container.  Note: This endpoint works only for containers with the `json-file` or `journald` logging driver.
     - parameter id: (path) ID or name of the container
     - parameter context: (query) The context to connect to. (optional)
     - parameter follow: (query) Keep connection after returning logs. (optional, default to false)
     - parameter stdout: (query) Return logs from &#x60;stdout&#x60; (optional, default to false)
     - parameter stderr: (query) Return logs from &#x60;stderr&#x60; (optional, default to false)
     - parameter since: (query) Only return logs since this time, as a UNIX timestamp (optional, default to 0)
     - parameter until: (query) Only return logs before this time, as a UNIX timestamp (optional, default to 0)
     - parameter timestamps: (query) Add timestamps to every log line (optional, default to false)
     - parameter tail: (query) Only return this number of log lines from the end of the logs. Specify as an integer or &#x60;all&#x60; to output all log lines.  (optional, default to "all")
     - returns: URL
     */
    public static func containerStreamLogs(host: URL, id: String, context: String? = nil, stdout: Bool? = nil, stderr: Bool? = nil, since: Int? = nil, until: Int? = nil, timestamps: Bool? = nil, tail: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> APIStreamResponse<ContainerLogResponseItem> {
        try await session.stream(APIRequest(method: .GET, host: host, path: ContainerAPIPath.containerLogs(id: id), query: [
            "context": context,
            "follow": true,
            "stdout": stdout,
            "stderr": stderr,
            "since": since,
            "until": until,
            "timestamps": timestamps,
            "tail": tail,
        ]))
    }
    
    /**
     Pause a container
     - POST /containers/{id}/pause
     - Use the freezer cgroup to suspend all processes in a container.  Traditionally, when suspending a process the `SIGSTOP` signal is used, which is observable by the process being suspended. With the freezer cgroup the process is unaware, and unable to capture, that it is being suspended, and subsequently resumed.
     - parameter id: (path) ID or name of the container
     - parameter context: (query) The context to connect to. (optional)
     
     */
    public static func containerPause(host: URL, id: String, context: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws {
        try await session.load(APIRequest(method: .POST, host: host, path: ContainerAPIPath.containerPause(id: id), query: [
            "context": context,
        ]))
    }
    
    /**
     Delete stopped containers
     - POST /containers/prune
     - parameter context: (query) The contexts to connect to. (optional)
     - parameter filters: (query) Filters to process on the prune list, encoded as JSON (a &#x60;map[string][]string&#x60;).  Available filters: - &#x60;until&#x3D;&lt;timestamp&gt;&#x60; Prune containers created before this timestamp. The &#x60;&lt;timestamp&gt;&#x60; can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. &#x60;10m&#x60;, &#x60;1h30m&#x60;) computed relative to the daemon machine’s time. - &#x60;label&#x60; (&#x60;label&#x3D;&lt;key&gt;&#x60;, &#x60;label&#x3D;&lt;key&gt;&#x3D;&lt;value&gt;&#x60;, &#x60;label!&#x3D;&lt;key&gt;&#x60;, or &#x60;label!&#x3D;&lt;key&gt;&#x3D;&lt;value&gt;&#x60;) Prune containers with (or without, in case &#x60;label!&#x3D;...&#x60; is used) the specified labels.  (optional)
     - returns: ContainerPruneResponse
     */
    public static func containerPrune(host: URL, context: [String]? = nil, filters: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> ContainerPruneResponse {
        try await session.load(APIRequest(method: .POST, host: host, path: ContainerAPIPath.containerPrune, query: [
            "context": context,
            "filters": filters,
        ]))
    }
    
    /**
     Rename a container
     - POST /containers/{id}/rename
     - parameter id: (path) ID or name of the container
     - parameter name: (query) New name for the container
     - parameter context: (query) The context to connect to. (optional)
     
     */
    public static func containerRename(host: URL, id: String, name: String, context: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws {
        try await session.load(APIRequest(method: .POST, host: host, path: ContainerAPIPath.containerRename(id: id), query: [
            "context": context,
            "name": name,
        ]))
    }
    
    /**
     Resize a container TTY
     - POST /containers/{id}/resize
     - Resize the TTY for a container.
     - parameter id: (path) ID or name of the container
     - parameter context: (query) The context to connect to. (optional)
     - parameter h: (query) Height of the TTY session in characters (optional)
     - parameter w: (query) Width of the TTY session in characters (optional)
     
     */
    public static func containerResize(host: URL, id: String, context: String? = nil, h: Int? = nil, w: Int? = nil, session: NetworkingSession = NetworkingSession.shared) async throws {
        try await session.load(APIRequest(method: .POST, host: host, path: ContainerAPIPath.containerResize(id: id), query: [
            "context": context,
            "h": h,
            "w": w,
        ]))
    }
    
    /**
     Restart a container
     - POST /containers/{id}/restart
     - parameter id: (path) ID or name of the container
     - parameter context: (query) The context to connect to. (optional)
     - parameter t: (query) Number of seconds to wait before killing the container (optional)
     
     */
    public static func containerRestart(host: URL, id: String, context: String? = nil, t: Int? = nil, session: NetworkingSession = NetworkingSession.shared) async throws {
        try await session.load(APIRequest(method: .POST, host: host, path: ContainerAPIPath.containerRestart(id: id), query: [
            "context": context,
            "t": t,
        ]))
    }
    
    /**
     Start a container
     - POST /containers/{id}/start
     - parameter id: (path) ID or name of the container
     - parameter context: (query) The context to connect to. (optional)
     - parameter detachKeys: (query) Override the key sequence for detaching a container. Format is a single character &#x60;[a-Z]&#x60; or &#x60;ctrl-&lt;value&gt;&#x60; where &#x60;&lt;value&gt;&#x60; is one of: &#x60;a-z&#x60;, &#x60;@&#x60;, &#x60;^&#x60;, &#x60;[&#x60;, &#x60;,&#x60; or &#x60;_&#x60;.  (optional)
     
     */
    public static func containerStart(host: URL, id: String, context: String? = nil, detachKeys: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws {
        try await session.load(APIRequest(method: .POST, host: host, path: ContainerAPIPath.containerStart(id: id), query: [
            "context": context,
            "detachKeys": detachKeys,
        ]))
    }
    
    /**
     Get container stats based on resource usage
     - GET /containers/{id}/stats
     - This endpoint returns a live stream of a container’s resource usage statistics.  The `precpu_stats` is the CPU statistic of the *previous* read, and is used to calculate the CPU usage percentage. It is not an exact copy of the `cpu_stats` field.  If either `precpu_stats.online_cpus` or `cpu_stats.online_cpus` is nil then for compatibility with older daemons the length of the corresponding `cpu_usage.percpu_usage` array should be used.  On a cgroup v2 host, the following fields are not set * `blkio_stats`: all fields other than `io_service_bytes_recursive` * `cpu_stats`: `cpu_usage.percpu_usage` * `memory_stats`: `max_usage` and `failcnt` Also, `memory_stats.stats` fields are incompatible with cgroup v1.  To calculate the values shown by the `stats` command of the docker cli tool the following formulas can be used: * used_memory = `memory_stats.usage - memory_stats.stats.cache` * available_memory = `memory_stats.limit` * Memory usage % = `(used_memory / available_memory) * 100.0` * cpu_delta = `cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage` * system_cpu_delta = `cpu_stats.system_cpu_usage - precpu_stats.system_cpu_usage` * number_cpus = `lenght(cpu_stats.cpu_usage.percpu_usage)` or `cpu_stats.online_cpus` * CPU usage % = `(cpu_delta / system_cpu_delta) * number_cpus * 100.0`
     - parameter id: (path) ID or name of the container
     - parameter context: (query) The context to connect to. (optional)
     - parameter stream: (query) Stream the output. If false, the stats will be output once and then it will disconnect.  (optional, default to true)
     - parameter oneShot: (query) Only get a single stat instead of waiting for 2 cycles. Must be used with &#x60;stream&#x3D;false&#x60;.  (optional, default to false)
     - returns: [ContainerStatsResponse]
     */
    public static func containerStats(host: URL, id: String, context: String? = nil, oneShot: Bool? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> ContainerStatsResponse {
        try await session.load(APIRequest(method: .GET, host: host, path: ContainerAPIPath.containerStats(id: id), query: [
            "context": context,
            "stream": false,
            "oneShot": oneShot,
        ]))
    }
    
    /**
     Get container stats based on resource usage
     - GET /containers/{id}/stats
     - This endpoint returns a live stream of a container’s resource usage statistics.  The `precpu_stats` is the CPU statistic of the *previous* read, and is used to calculate the CPU usage percentage. It is not an exact copy of the `cpu_stats` field.  If either `precpu_stats.online_cpus` or `cpu_stats.online_cpus` is nil then for compatibility with older daemons the length of the corresponding `cpu_usage.percpu_usage` array should be used.  On a cgroup v2 host, the following fields are not set * `blkio_stats`: all fields other than `io_service_bytes_recursive` * `cpu_stats`: `cpu_usage.percpu_usage` * `memory_stats`: `max_usage` and `failcnt` Also, `memory_stats.stats` fields are incompatible with cgroup v1.  To calculate the values shown by the `stats` command of the docker cli tool the following formulas can be used: * used_memory = `memory_stats.usage - memory_stats.stats.cache` * available_memory = `memory_stats.limit` * Memory usage % = `(used_memory / available_memory) * 100.0` * cpu_delta = `cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage` * system_cpu_delta = `cpu_stats.system_cpu_usage - precpu_stats.system_cpu_usage` * number_cpus = `lenght(cpu_stats.cpu_usage.percpu_usage)` or `cpu_stats.online_cpus` * CPU usage % = `(cpu_delta / system_cpu_delta) * number_cpus * 100.0`
     - parameter id: (path) ID or name of the container
     - parameter context: (query) The context to connect to. (optional)
     - parameter stream: (query) Stream the output. If false, the stats will be output once and then it will disconnect.  (optional, default to true)
     - parameter oneShot: (query) Only get a single stat instead of waiting for 2 cycles. Must be used with &#x60;stream&#x3D;false&#x60;.  (optional, default to false)
     - returns: [ContainerStatsResponse]
     */
    public static func containerStreamStats(host: URL, id: String, context: String? = nil, oneShot: Bool? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> APIStreamResponse<ContainerStatsResponse> {
        try await session.stream(APIRequest(method: .GET, host: host, path: ContainerAPIPath.containerStats(id: id), query: [
            "context": context,
            "stream": true,
            "oneShot": oneShot,
        ]))
    }
    
    /**
     Stop a container
     - POST /containers/{id}/stop
     - parameter id: (path) ID or name of the container
     - parameter context: (query) The context to connect to. (optional)
     - parameter t: (query) Number of seconds to wait before killing the container (optional)
     
     */
    public static func containerStop(host: URL, id: String, context: String? = nil, t: Int? = nil, session: NetworkingSession = NetworkingSession.shared) async throws {
        try await session.load(APIRequest(method: .POST, host: host, path: ContainerAPIPath.containerStop(id: id), query: [
            "context": context,
            "t": t,
        ]))
    }
    
    /**
     List processes running inside a container
     - GET /containers/{id}/top
     - On Unix systems, this is done by running the `ps` command. This endpoint is not supported on Windows.
     - parameter id: (path) ID or name of the container
     - parameter context: (query) The context to connect to. (optional)
     - parameter psArgs: (query) The arguments to pass to &#x60;ps&#x60;. For example, &#x60;aux&#x60; (optional, default to "-ef")
     - returns: ContainerTopResponse
     */
    public static func containerTop(host: URL, id: String, context: String? = nil, psArgs: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> ContainerTopResponse {
        try await session.load(APIRequest(method: .GET, host: host, path: ContainerAPIPath.containerTop(id: id), query: [
            "context": context,
            "psArgs": psArgs,
        ]))
    }
    
    /**
     Unpause a container
     - POST /containers/{id}/unpause
     - Resume a container which has been paused.
     - parameter id: (path) ID or name of the container
     - parameter context: (query) The context to connect to. (optional)
     
     */
    public static func containerUnpause(host: URL, id: String, context: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws {
        try await session.load(APIRequest(method: .POST, host: host, path: ContainerAPIPath.containerUnpause(id: id), query: [
            "context": context,
        ]))
    }
    
    /**
     Update a container
     - POST /containers/{id}/update
     - Change various configuration options of a container without having to recreate it.
     - parameter id: (path) ID or name of the container
     - parameter update: (body)
     - parameter context: (query) The context to connect to. (optional)
     - returns: ContainerUpdateResponse
     */
    public static func containerUpdate(host: URL, id: String, update: ContainerUpdateConfig, context: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> ContainerUpdateResponse {
        try await session.load(APIRequest(method: .POST, host: host, path: ContainerAPIPath.containerUpdate(id: id), query: [
            "context": context,
        ], body: update))
    }
    
    /**
     Wait for a container
     - POST /containers/{id}/wait
     - Block until a container stops, then returns the exit code.
     - parameter id: (path) ID or name of the container
     - parameter context: (query) The context to connect to. (optional)
     - parameter condition: (query) Wait until a container state reaches the given condition, either &#39;not-running&#39; (default), &#39;next-exit&#39;, or &#39;removed&#39;.  (optional, default to "not-running")
     - returns: ContainerWaitResponse
     */
    public static func containerWait(host: URL, id: String, context: String? = nil, condition: String? = nil, session: NetworkingSession = NetworkingSession.shared) async throws -> ContainerWaitResponse {
        try await session.load(APIRequest(method: .POST, host: host, path: ContainerAPIPath.containerWait(id: id), query: [
            "context": context,
            "condition": condition,
        ]))
    }
}
